<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <title>CSV zu RSS</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    body {
      margin: 0;
      padding: 16px;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0d1117;
      color: #e5e7eb;
    }

    h1 {
      font-size: 1.2rem;
      margin: 0 0 12px;
    }

    label {
      display: block;
      margin-top: 10px;
      font-size: 0.85rem;
    }

    input[type="text"],
    input[type="url"],
    select,
    textarea {
      width: 100%;
      box-sizing: border-box;
      margin-top: 4px;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid #374151;
      background: #020617;
      color: #e5e7eb;
      font-family: inherit;
      font-size: 0.9rem;
    }

    textarea {
      min-height: 260px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace;
      font-size: 0.8rem;
      white-space: pre;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: none;
      border-color: #3b82f6;
      box-shadow: 0 0 0 1px rgba(59,130,246,0.4);
    }

    .row {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      margin-top: 10px;
      margin-bottom: 6px;
    }

    button {
      border-radius: 999px;
      border: 1px solid #374151;
      background: #2563eb;
      color: #f9fafb;
      padding: 6px 12px;
      font-size: 0.85rem;
      cursor: pointer;
    }

    button.secondary {
      background: #020617;
    }

    small {
      color: #9ca3af;
      font-size: 0.75rem;
    }

    .status {
      margin-top: 6px;
      font-size: 0.8rem;
      color: #9ca3af;
    }

    hr {
      margin: 14px 0;
      border: 0;
      border-top: 1px solid #1f2937;
    }
  </style>
</head>
<body>

<h1>CSV zu RSS (RSS 2.0)</h1>

<label>
  CSV Datei
  <input type="file" id="csvFile" accept=".csv,text/csv">
</label>

<label>
  Trennzeichen
  <select id="delimiter">
    <option value="auto">Automatisch erkennen</option>
    <option value=",">Komma ,</option>
    <option value=";">Semikolon ;</option>
    <option value="tab">Tabulator</option>
  </select>
</label>

<div class="status" id="status">Noch keine CSV geladen.</div>

<hr>

<label>
  Channel Titel
  <input type="text" id="channelTitle" value="Mein CSV Feed">
</label>

<label>
  Channel Link
  <input type="url" id="channelLink" value="https://example.com">
</label>

<label>
  Channel Beschreibung
  <input type="text" id="channelDescription" value="RSS Feed aus einer CSV Datei.">
</label>

<hr>

<small>Standard erwartet Kopfzeile: <code>Titel,URL,Beschreibung,Datum</code></small>

<label>
  Spaltenname für Titel
  <input type="text" id="colTitle" value="Titel">
</label>

<label>
  Spaltenname für Link
  <input type="text" id="colLink" value="URL">
</label>

<label>
  Spaltenname für Beschreibung
  <input type="text" id="colDescription" value="Beschreibung">
</label>

<label>
  Spaltenname für Datum
  <input type="text" id="colPubDate" value="Datum">
  <small>ISO Datum oder schon fertiges RSS Datum ist ok.</small>
</label>

<label>
  Umgang mit fehlendem Datum
  <select id="dateFallback">
    <option value="today">Heutiges Datum einsetzen</option>
    <option value="skip">Einträge ohne Datum überspringen</option>
  </select>
</label>

<div class="row">
  <button id="btnGenerate">RSS generieren</button>
  <button id="btnCopy" class="secondary">In Zwischenablage kopieren</button>
  <button id="btnDownload" class="secondary">rss.xml herunterladen</button>
</div>

<div class="status" id="itemInfo"></div>

<label>
  RSS Ausgabe
  <textarea id="rssOutput" spellcheck="false"></textarea>
</label>

<script>
  const csvFileInput = document.getElementById("csvFile");
  const delimiterSelect = document.getElementById("delimiter");
  const statusEl = document.getElementById("status");
  const itemInfoEl = document.getElementById("itemInfo");
  const rssOutput = document.getElementById("rssOutput");

  const channelTitleInput = document.getElementById("channelTitle");
  const channelLinkInput = document.getElementById("channelLink");
  const channelDescriptionInput = document.getElementById("channelDescription");

  const colTitleInput = document.getElementById("colTitle");
  const colLinkInput = document.getElementById("colLink");
  const colDescriptionInput = document.getElementById("colDescription");
  const colPubDateInput = document.getElementById("colPubDate");
  const dateFallbackSelect = document.getElementById("dateFallback");

  const btnGenerate = document.getElementById("btnGenerate");
  const btnCopy = document.getElementById("btnCopy");
  const btnDownload = document.getElementById("btnDownload");

  let currentCSVText = "";
  let parsed = { headers: [], rows: [], delimiter: "," };

  function detectDelimiter(text) {
    const lines = text.split(/\r?\n/).slice(0, 5).filter(Boolean);
    const counts = { ",": 0, ";": 0, tab: 0 };

    lines.forEach(line => {
      counts[","] += (line.match(/,/g) || []).length;
      counts[";"] += (line.match(/;/g) || []).length;
      counts["tab"] += (line.match(/\t/g) || []).length;
    });

    let best = ",";
    let max = -1;
    for (const k in counts) {
      if (counts[k] > max) {
        max = counts[k];
        best = k;
      }
    }

    return best === "tab" ? "\t" : best;
  }

  function splitLine(line, d) {
    const result = [];
    let current = "";
    let inQuotes = false;

    for (let i = 0; i < line.length; i++) {
      const ch = line[i];
      const next = line[i + 1];

      if (ch === '"') {
        if (inQuotes && next === '"') {
          current += '"';
          i++;
        } else {
          inQuotes = !inQuotes;
        }
      } else if (ch === d && !inQuotes) {
        result.push(current);
        current = "";
      } else {
        current += ch;
      }
    }
    result.push(current);
    return result;
  }

  function parseCSV(text, delimiterMode) {
    const lines = text.split(/\r?\n/).filter(l => l.trim().length > 0);
    if (!lines.length) return { headers: [], rows: [], delimiter: "," };

    const delimiter = delimiterMode === "auto" ? detectDelimiter(text) :
                      delimiterMode === "tab" ? "\t" : delimiterMode;

    const headers = splitLine(lines[0], delimiter).map(h => h.trim());
    const rows = [];

    for (let i = 1; i < lines.length; i++) {
      const parts = splitLine(lines[i], delimiter);
      if (parts.every(p => p.trim().length === 0)) continue;
      const row = {};
      headers.forEach((h, idx) => {
        row[h] = (parts[idx] || "").trim();
      });
      rows.push(row);
    }

    return { headers, rows, delimiter };
  }

  function escapeXML(str) {
    return String(str || "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&apos;");
  }

  function toRssDate(dateString) {
    if (!dateString) return null;
    const d = new Date(dateString);
    if (!isNaN(d.getTime())) return d.toUTCString();
    const d2 = new Date(dateString.replace(/\./g, "/"));
    if (!isNaN(d2.getTime())) return d2.toUTCString();
    return null;
  }

  function todayRssDate() {
    return new Date().toUTCString();
  }

  csvFileInput.addEventListener("change", () => {
    const file = csvFileInput.files[0];
    if (!file) return;

    const reader = new FileReader();
    reader.onload = e => {
      currentCSVText = e.target.result;
      parsed = parseCSV(currentCSVText, delimiterSelect.value);
      statusEl.textContent =
        "CSV geladen. Spalten: " + parsed.headers.join(", ") +
        " | Zeilen: " + parsed.rows.length;
      itemInfoEl.textContent = "";
    };
    reader.readAsText(file, "utf-8");
  });

  delimiterSelect.addEventListener("change", () => {
    if (!currentCSVText) return;
    parsed = parseCSV(currentCSVText, delimiterSelect.value);
    statusEl.textContent =
      "CSV neu geparst. Spalten: " + parsed.headers.join(", ") +
      " | Zeilen: " + parsed.rows.length;
    itemInfoEl.textContent = "";
  });

  btnGenerate.addEventListener("click", () => {
    if (!currentCSVText || !parsed.rows.length) {
      alert("Bitte zuerst eine CSV laden.");
      return;
    }

    const channelTitle = channelTitleInput.value.trim() || "CSV Feed";
    const channelLink = channelLinkInput.value.trim() || "https://example.com";
    const channelDescription = channelDescriptionInput.value.trim() || "RSS Feed aus CSV.";

    const colTitle = colTitleInput.value.trim();
    const colLink = colLinkInput.value.trim();
    const colDescription = colDescriptionInput.value.trim();
    const colPubDate = colPubDateInput.value.trim();
    const fallbackMode = dateFallbackSelect.value;

    const lines = [];
    lines.push('<?xml version="1.0" encoding="UTF-8"?>');
    lines.push('<rss version="2.0">');
    lines.push("  <channel>");
    lines.push("    <title>" + escapeXML(channelTitle) + "</title>");
    lines.push("    <link>" + escapeXML(channelLink) + "</link>");
    lines.push("    <description>" + escapeXML(channelDescription) + "</description>");
    lines.push("    <lastBuildDate>" + todayRssDate() + "</lastBuildDate>");
    lines.push("    <generator>CSV to RSS HTML Tool</generator>");

    let count = 0;

    parsed.rows.forEach((row, idx) => {
      const title = colTitle ? row[colTitle] : "";
      const link = colLink ? row[colLink] : "";
      const desc = colDescription ? row[colDescription] : "";

      let pubDateValue = "";
      if (colPubDate && row[colPubDate]) {
        const rssDate = toRssDate(row[colPubDate]);
        pubDateValue = rssDate || row[colPubDate];
      } else {
        if (fallbackMode === "today") {
          pubDateValue = todayRssDate();
        } else if (fallbackMode === "skip") {
          pubDateValue = null;
        }
      }

      if (!title && !desc && !link) return;

      lines.push("    <item>");
      if (title) lines.push("      <title>" + escapeXML(title) + "</title>");
      if (link) {
        lines.push("      <link>" + escapeXML(link) + "</link>");
        lines.push('      <guid isPermaLink="true">' + escapeXML(link) + "</guid>");
      } else {
        lines.push('      <guid isPermaLink="false">' + escapeXML("item-" + idx) + "</guid>");
      }
      if (desc) lines.push("      <description>" + escapeXML(desc) + "</description>");
      if (pubDateValue) lines.push("      <pubDate>" + escapeXML(pubDateValue) + "</pubDate>");
      lines.push("    </item>");
      count++;
    });

    lines.push("  </channel>");
    lines.push("</rss>");

    rssOutput.value = lines.join("\n");
    itemInfoEl.textContent = count + " Items im Feed.";
  });

  btnCopy.addEventListener("click", async () => {
    const text = rssOutput.value;
    if (!text.trim()) {
      alert("Noch keine RSS Ausgabe vorhanden.");
      return;
    }
    try {
      await navigator.clipboard.writeText(text);
      alert("RSS in die Zwischenablage kopiert.");
    } catch (e) {
      alert("Kopieren nicht möglich. Text manuell markieren.");
    }
  });

  btnDownload.addEventListener("click", () => {
    const text = rssOutput.value;
    if (!text.trim()) {
      alert("Noch keine RSS Ausgabe vorhanden.");
      return;
    }
    const blob = new Blob([text], { type: "application/rss+xml;charset=utf-8" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "rss.xml";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  });
</script>

</body>
</html>
